---
title: "[C++] for문 안에서 전위연산자& 후위연산자"
excerpt: ""

categories:
  - C++
tags:
  - [C++]

permalink: /languages/cpp/1

toc: true
toc_sticky: true

date: 2025-03-10 #21:46:32+0900
#last_modified_at: 2025-02-16 21:46:32+0900
---

# **C++에서 `for` 문에서 후위(`i++`)와 전위(`++i`) 연산자의 차이**

`for` 루프에서 증가 연산자는 반복 횟수를 결정하는 중요한 역할을 합니다.

여기서 **후위 증가 연산자 (`i++`)** 와 **전위 증가 연산자 (`++i`)** 의 차이를 이해하는 것이 중요

---

### **1. 후위 증가 연산자 (`i++`)**

후위 증가 연산자는 **현재 값을 사용한 후 증가함**.

```cpp

for (int i = 0; i < 5; i++) {
    cout << i << " ";
}
```

### **실행 순서**

1. `i = 0` (초기화)
2. 조건 `i < 5` 확인 → 참 → `cout << i` 실행
3. `i++` 실행 (현재 값 `i`를 사용한 후 증가)
4. `i = 1`이 되고 다시 조건 확인
5. 위 과정 반복

### **출력 결과**

```

0 1 2 3 4
```

---

### **2. 전위 증가 연산자 (`++i`)**

전위 증가 연산자는 **먼저 증가한 후 사용됨**.

```cpp

for (int i = 0; i < 5; ++i) {
    cout << i << " ";
}
```

### **실행 순서**

1. `i = 0` (초기화)
2. 조건 `i < 5` 확인 → 참 → `++i` 실행 (먼저 증가)
3. `cout << i` 실행
4. 위 과정 반복

### **출력 결과**

```

0 1 2 3 4
```

(후위 연산자와 동일한 결과)

---

### **3. 후위(`i++`) vs 전위(`++i`) 차이**

### **(1) 성능 차이**

- **후위 증가 (`i++`)**
    - 이전 값을 저장한 후 증가 → 불필요한 메모리 연산 발생
- **전위 증가 (`++i`)**
    - 증가 후 즉시 반환 → 불필요한 복사 연산 없음
- **일반적인 `int` 루프에서는 차이가 거의 없음.**
    - 하지만 **C++의 `iterator`(반복자)에서 성능 차이가 발생**할 수 있음.

### **(2) `for` 루프에서의 사용 추천**

- **일반적인 정수 (`int`) 반복에는 `i++`과 `++i`의 차이가 크지 않음.**
- **C++ STL (`std::vector<int>::iterator`)을 사용할 때는 `++it`(전위 증가)가 더 효율적**
    
    ```cpp
    
    for (auto it = vec.begin(); it != vec.end(); ++it) { // ++it 사용 추천
        cout << *it << " ";
    }
    ```
    
    - `it++`은 **복사 후 증가**하기 때문에 **불필요한 메모리 연산이 발생**할 수 있음.
    - `++it`은 **증가 후 반환**하므로 더 빠름.

---

⇒ 정리

| 구분 | 후위 증가 (`i++`) | 전위 증가 (`++i`) |
| --- | --- | --- |
| 동작 방식 | 값 사용 후 증가 | 먼저 증가 후 사용 |
| 성능 차이 | 불필요한 복사 발생 | 불필요한 연산 없음 |
| `int` 루프에서 | 차이 거의 없음 | 차이 거의 없음 |
| `iterator`에서 | 메모리 낭비 가능 | 성능 최적화됨 (추천) |

**`for` 루프에서 `int`를 증가시킬 때는 차이가 거의 없지만, STL 반복자(`iterator`)를 다룰 때는 `++it`을 쓰는 것이 더 좋다**

## **그렇다면 왜 `for` 문에서 `i++` 과 `++i`의 결과가 같은가?**

```cpp

for (int i = 0; i < 5; i++) {
    cout << i << " ";
}

```

```cpp

for (int i = 0; i < 5; ++i) {
    cout << i << " ";
}

```

위 두 코드 모두 출력 결과는 **`0 1 2 3 4`** 이다.

---

### **1. `for` 루프의 동작 방식**

`for` 문은 다음 구조를 가집니다:

```cpp

for (초기화; 조건; 증감) {
    // 반복 실행할 코드

```

실행 순서는 다음과 같습니다:

1️⃣ **초기화 (`int i = 0;`)** → `i`를 0으로 설정

2️⃣ **조건 검사 (`i < 5;`)** → `i`가 5 미만이면 블록 실행

3️⃣ **반복 블록 실행 (`cout << i;`)**

4️⃣ **증감 (`i++` 또는 `++i`)** → `i` 증가

5️⃣ **조건 검사 → 반복**

### **2. 후위 증가 (`i++`)**

```cpp

for (int i = 0; i < 5; i++) {
    cout << i << " ";
}
```

- `i++`은 후위 증가 연산자이므로, **현재 값으로 조건을 비교하고 블록 실행 후 증가**.
- 하지만 증가는 `cout << i;` 실행 후 일어남.
- **즉, 증가 연산은 루프의 끝에서 수행되므로 출력 순서에 영향을 주지 않음.**

---

### **3. 전위 증가 (`++i`)**

```cpp

for (int i = 0; i < 5; ++i) {
    cout << i << " ";
}
```

- `++i`는 전위 증가 연산자이므로, **먼저 증가한 후 값을 반환**.
- 하지만 `for` 문에서 `++i`가 실행되는 위치는 **루프 블록 실행 이후**이므로,`cout << i;` 전에 증가되지 않음.

---

### **4. 후위(`i++`) vs 전위(`++i`)에서 결과가 같은 이유**

### **⇒ 증가 연산이 `cout << i;` 실행 이후에 발생**

- `i++`은 현재 값 사용 후 증가
- `++i`는 증가 후 사용
- 하지만 `for` 문에서 증가 연산(`i++` or `++i`)이 수행되는 **위치**는 `cout << i;` 실행 이후이므로,
실제 출력되는 값이 동일함.

### **5. 증가 연산의 수행 위치**

### **1) 후위 증가 (`i++`)**

```cpp

for (int i = 0; i < 5; i++) {
```

- **조건 검사**: `i < 5`
- **코드 실행**: `cout << i;`
- **후위 증가 (`i++`) 실행**
- **i가 증가한 후 다시 조건 검사**

### **2) 전위 증가 (`++i`)**

```cpp

for (int i = 0; i < 5; ++i) {
```

- **조건 검사**: `i < 5`
- **코드 실행**: `cout << i;`
- **전위 증가 (`++i`) 실행**
- **i가 증가한 후 다시 조건 검사**

즉, **증가 연산이 `cout << i;` 실행 이후에 발생하므로 `i++`과 `++i` 모두 같은 값을 출력**합니다.

---

## **결론**

`for` 문에서 `i++`과 `++i`가 같은 결과를 출력하는 이유는 **증가 연산(`i++` or `++i`)이 루프 블록 실행 이후에 발생하기 때문**.

따라서, 출력하는 시점에서는 증가하기 전의 값이 사용되므로 같은 결과가 나온다!